---
# 当前页面内容标题
title: 四、Redis持久化
# 分类
category:
  - redis
# 标签
tag: 
  - redis
  - NOSQL
  - K,V缓存数据库
  - 非关系型数据库
sticky: false
# 是否收藏在博客主题的文章列表中，当填入数字时，数字越大，排名越靠前。
star: false
# 是否将该文章添加至文章列表中
article: true
# 是否将该文章添加至时间线中
timeline: true
---

## 01、总体介绍

### 官网地址

官网：https://redis.io/docs/manual/persistence/

![](./images/2023-03-29-00-08-13-image.png)

### 为什么要持久化？

## 02、持化双雄

### 一图

![](./images/2023-03-29-00-09-18-image.png)

### RDB（Redis DataBase）

#### 官网介绍

![](./images/2023-03-29-00-10-47-image.png)

> RDB（Redis 数据库）：RDB 持久性以指定的时间间隔执行数据集的时间点快照。

#### 是什么？

> 在指定的时间间隔，执行数据集的时间点快照

实现类似照片记录效果的方式，就是把某一时刻的数据和状态以文件的形式写到磁盘上，也就是

快照。这样一来即使故障宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。

这个快照文件就称为RDB文件(dump.rdb)，其中，RDB就是Redis DataBase的缩写。

#### 能干嘛？

- 快照文件直接返回到内存里

- 一锅端
  
  - Redis的数据都在内存中，保存备份时它执行的是`全量快照`，也就是说，把内存中的所有数据都记录到磁盘中，一锅端

- RDB保存的是dump.rdb文件

#### 案例演示

##### 需求说明

![](./images/2023-03-29-00-16-35-image.png)

> RDB保存到磁盘的文件叫dump.rdb

##### 配置文件（6 VS 7）

- Redis6.0.16以下

![](./images/2023-03-29-00-17-59-image.png)

![](./images/2023-03-29-16-57-01-image.png)

- Redis6.2以及Redis-7.0.0

![](./images/2023-03-29-17-00-29-image.png)

##### 操作步骤

###### 自动触发

- Redis7版本，按照redis.conf里配置的save < seconds > < changes > 

![](./images/2023-03-29-17-03-04-image.png)

- 本次案例5秒2次修改

![](./images/2023-03-29-17-09-03-image.png)

- 修改dump文件保存路径

> 默认

![](./images/2023-03-29-17-10-33-image.png)

> 自定义修改的路径且可以进入redis里用CONFIG GET dir获取目录

![](./images/2023-03-29-17-10-52-image.png)

> 注意点：
> 
> - 如果你修改完以上的配置获取其他配置建议重新启动redis让其生效
> 
> - SHUTDOWN  关机
> 
> - quit 退出
> 
> - 然后重新启动

![](./images/2023-03-29-17-19-35-image.png)

- 修改dump文件名称

![](./images/2023-03-29-17-20-08-image.png)

- 触发备份

> 🚩第1次种情况

![](./images/2023-03-29-17-20-49-image.png)

> 第2种情况

![](./images/2023-03-29-17-21-12-image.png)

- 如何恢复

> 将备份文件（dump.rdb）移动到reids安装目录并启动服务即可

> ⚠️备份成功后故意用flushdb清空redis，看看是否可以恢复数据

![](./images/2023-03-29-17-23-37-image.png)

`结论`

执行flushall/flushdb命令也会产生dump.rdb文件，但是里面是空的，无意义

> ✅物理恢复，一定服务和备份分机隔离

![](./images/2023-03-29-17-25-20-image.png)

**备注：不可以把备份文件dump.rdb和生产redis服务器放在同一台机器，必须分开各自存储，以防生产机物理损坏后备份文件也挂了。**

###### 手动触发

- `save`和`bgsave`

> Redis提供了两个命令来生成RDB文件，分别是`save`和`bgsave`

![](./images/2023-03-29-17-28-36-image.png)

- SAVE

> 在主程序中执行会阻塞当前redis服务器，直到持久化工作完成，执行save命令期间，Redis不能处理其他命令，线上禁止使用

`案例`

![](./images/2023-03-29-17-30-46-image.png)

![](./images/2023-03-29-17-30-55-image.png)

- BGSAVE(默认)

> Redis会在后台异步进行快照操作，`不阻塞`
> 
> 快照同时还可以响应客户端请求，该触发方式，会fork一个子进程由子进程复制持久化过程

> 官网说明

![](./images/2023-03-29-17-35-05-image.png)

> Redis会使用bgsave对当前内存中的所有数据做快照，这个操作是子进程在后台完成的，这就允许主进程同时可以修改数据。

> fork是什么？

- 各位熟悉的

![](./images/2023-03-29-17-36-37-image.png)

- 操作系统角度

> -    在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，尽量避免膨胀。

`案例`

![](./images/2023-03-29-17-37-25-image.png)

![](./images/2023-03-29-17-37-33-image.png)

> LASTSAVE

可以通过lastsave命令获取最后一次成功执行快照的时间

`案例`

![](./images/2023-03-29-17-38-40-image.png)

![](./images/2023-03-29-17-38-46-image.png)

#### 优势

1. 官网说明

![](./images/2023-03-29-18-02-20-image.png)

![](./images/2023-03-29-18-04-23-image.png)

2. 小总结
- 适合大规模的数据恢复

- 按照业务定时备份

- 对数据完整性和一致性要求不高

- RDB文件在内存中的加载速度要比AOF快的多

#### 劣势

1. 官网说明

![](./images/2023-03-29-18-01-33-image.png)

![](./images/2023-03-29-18-01-50-image.png)

2. 小总结
- 在一定间隔使劲做一次备份，所以如果redis意外down掉的话，就会丢失从当前至最后一次快照期间的数据，`快照之间的数据会丢失`

- 内存数据的全量同步，如果数据量太大会导致I/O严重影响服务器性能

- RDB依赖于主进程的fork，在更大的数据集中，这可能会导致服务请求的瞬间延迟。fork的时候内存中的数据被克隆了一份，大致2倍的膨胀性，需要考虑
3. 数据丢失案例
- 正常登入数据

![](./images/2023-03-29-18-08-43-image.png)

- kill -9故意模拟意外down机

![](./images/2023-03-29-18-09-46-image.png)

- redis重启恢复，查看数据是否丢失

![](./images/2023-03-29-18-10-22-image.png)

#### 如何检查修复dump.rdb文件

![](./images/2023-03-29-18-11-12-image.png)

#### 哪些情况会触发RDB快照

- 配置文件中默认的快照配置

- 手动save/bgsave命令

- 执行flushdb/flushall命令也会产生dump.rdb文件，但里面是空的，没有意义

- 执行shutdown且没有设置开启AOF持久化

- 主从复制时，主节点自动触发

#### 如何禁用快照

- 动态所有停止RDB保存规则的方法：`redis-cli config set save ""`

- 快照禁用

![](./images/2023-03-29-18-14-46-image.png)

#### RDB优化配置项详解

> 配置文件SNAPSHOTTING模块

- save < seconds > < changes >

- dirfilename

- dir

- stop-writes-on-bgsave-error  建议为yes

![](./images/2023-03-29-18-17-23-image.png)

`默认yes`

`如果配置成no，表示你不在乎数据不一致或者有其他的手段发现和控制这种不一致，那么在快照写入失败时，也能确保redis继续接受新的写请求`

- rdbcompression    建议为yes

![](./images/2023-03-29-18-18-01-image.png)

| 默认yes                                                                             |
|:---------------------------------------------------------------------------------:|
| 对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。<br>如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能 |

- rdbchecksum    建议为yes

![](./images/2023-03-29-18-18-26-image.png)

| 默认yes                                                                      |
|:--------------------------------------------------------------------------:|
| 在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能 |

- rdb-del-sync-files    默认即可

![](./images/2023-03-29-18-18-44-image.png)

`rdb-del-sync-files：在没有持久性的情况下删除复制中使用的RDB文件启用。默认情况下no，此选项是禁用的。`

#### 小总结

![](./images/2023-03-29-18-19-28-image.png)

### AOF（Append Only File）

#### 官网介绍

![](./images/2023-03-29-22-09-05-image.png)

#### 是什么？

- `以日志的形式来记录每个写操作`，将Redis执行过的所有写指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容讲写操作从前到后执行一次以完成数据的恢复工作

- 默认情况下，redis是没有开启AOF（append Only File）的。

- 开启AOF功能需要设置配置： yes

#### 能干嘛？

![](./images/2023-03-29-22-13-34-image.png)

#### AOF保存的是appendonly.aof文件

#### AOF持久化工程流程

![](./images/2023-03-29-22-14-25-image.png)

| 1   | Client作为命令的来源，会有多个源头以及源源不断的请求命令。                                                                                   |
| --- | ------------------------------------------------------------------------------------------------------------------ |
| 2   | 在这些命令到达Redis Server 以后并不是直接写入AOF文件，会将其这些命令先放入AOF缓存中进行保存。这里的AOF缓冲区实际上是内存中的一片区域，存在的目的是当这些命令达到一定量以后再写入磁盘，避免频繁的磁盘IO操作。 |
| 3   | AOF缓冲会根据AOF缓冲区***同步文件的三种写回策略***将命令写入磁盘上的AOF文件。                                                                     |
| 4   | 随着写入AOF内容的增加为避免文件膨胀，会根据规则进行命令的合并(又称***AOF重写)***，从而起到AOF文件压缩的目的。                                                    |
| 5   | 当Redis Server 服务器重启的时候会从AOF文件载入数据。                                                                                 |

#### AOF缓冲区三种写回策略

##### 三种写回策略

![](./images/2023-03-29-22-19-26-image.png)

- Always

> 同步写回，每个写命令执行完立刻同步地将日志写会磁盘

- everysec

> 每秒写回，每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔1秒把缓冲区中的内容写入磁盘

- no

> 操作系统控制的写回，每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写会磁盘

##### 三种写回策略小总结

![](./images/2023-03-29-22-20-01-image.png)

#### 案例演示和说明    AOF配置/启动/修复/恢复

##### 配置文件说明（6 VS 7）

###### 如何开启aof

![](./images/2023-03-29-22-22-35-image.png)

![](./images/2023-03-29-22-22-47-image.png)

###### 使用默认写回策略，每秒钟

![](./images/2023-03-29-22-23-24-image.png)

###### aof文件-保存路径

- redis6

> AOF保存文件的位置和RDB保存文件的位置一样，都是通过redis.conf配置文件的dir配置

> 官方文档

![](./images/2023-03-30-00-24-50-image.png)

- redis7之后最新

![](./images/2023-03-30-15-10-30-image.png)

> 最终路径

![](./images/2023-03-30-15-10-54-image.png)

`dir + appenddirname`

###### aof文件-保存名称

- redis6

![](./images/2023-03-30-15-11-41-image.png)

有且只有一个

- Redis7.0 Multi Part AOF的设计

> 官网说明

![](./images/2023-03-30-15-12-31-image.png)

> 从1到3
> 
> - base基本文件
> 
> - incr增量文件
> 
> - mainfest清单文件

![](./images/2023-03-30-15-28-42-image.png)

![](./images/2023-03-30-15-28-50-image.png)

> Redis7.0 config中对应的配置项

![](./images/2023-03-30-15-14-07-image.png)

##### 正常恢复

1. 启动：设置Yes

> 修改默认的appendonly no，改为`yes`

2. 写操作继续，生成aof文件到指定的目录

![](./images/2023-03-30-15-46-16-image.png)

3. 恢复1：重启redis然后重新加载，结果OK

4. 恢复2
- 写入数据到redis，然后flushdb+shutdown服务器

- 新生成了dump和aof

- 备份新生成的aof.bak，然后删除dump/aof再看恢复

![](./images/2023-03-30-15-48-11-image.png)

- 重启redis然后重新加载试试？？？

![](./images/2023-03-30-15-48-47-image.png)

- 停止服务器，拿出我们的备份修改后再重新启动服务器看看

![](./images/2023-03-30-15-49-43-image.png)

![](./images/2023-03-30-15-49-49-image.png)

##### 异常恢复

1. 故意乱写正常的AOF文件，模拟网络闪断文件写error

> vim /myredis/appendonlydir/appendonly.aof.1.incr.aof

![](./images/2023-03-30-15-51-39-image.png)

2. 重启Redis之后就会进行AOF文件的载入，发现启动都不行了，o(╥﹏╥)o

![](./images/2023-03-30-15-52-34-image.png)

3. 异常修复命令：redis-check-aof --fix进行修复

![](./images/2023-03-30-15-53-14-image.png)

> redis-check-aof --fix 进行修复

4. 重启OK

![](./images/2023-03-30-15-53-41-image.png)

#### 优势

![](./images/2023-03-30-15-54-17-image.png)

![](./images/2023-03-30-15-54-26-image.png)

> 更好的保护数据不丢失、性能高，可做紧急恢复

#### 劣势

![](./images/2023-03-30-15-55-36-image.png)

![](./images/2023-03-30-15-55-44-image.png)

- 相同的数据集的数据而言aof文件远大于rdb文件，恢复速度慢于rdb

- aof运行效率要慢于rdb，每秒同步策略效率较好，不同步效率和rdb相同

#### AOF重写机制

##### 是什么？

- 官网

![](./images/2023-03-30-16-02-17-image.png)

![](./images/2023-03-30-16-02-29-image.png)

- 一句话

> 启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。

##### 触发机制

- 官网默认配置

![](./images/2023-03-30-16-06-06-image.png)

注意 ，同时满足，且的关系才会触发

1 根据上次重写后的aof大小，判断当前aof大小是不是增长了1倍

2 重写时满足的文件大小

- `自动触发`

满足配置文件中的选项后，Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时

- `手动触发`

客户端向服务器发送`bgrewriteaof`命令

##### 案例说明

- 需求说明

启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。

**举个例子：**比如有个key 

一开始你  set k1 v1

然后改成  set k1 v2

最后改成  set k1 v3

如果不重写，那么这3条语句都在aof文件中，内容占空间不说启动的时候都要执行一遍，共计3条命令；

但是，我们实际效果只需要set k1 v3这一条，所以，

开启重写后，只需要保存set k1 v3就可以了只需要保留最后一次修改值，相当于给aof文件瘦身减肥，性能更好。

AOF重写不仅降低了文件的占用空间，同时更小的AOF也可以更快地被Redis加载。

- 需求验证

启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。

- 步骤
1. 前期配置准备

> 开启aof

![](./images/2023-03-30-16-22-15-image.png)

> 重写峰值修改为  `1k`

![](./images/2023-03-30-16-22-58-image.png)

> 关闭混合，设置为no

![](./images/2023-03-30-16-24-22-image.png)

> 删除之前的全部aof和rdb，清除干扰项

2. 自动触发案例01

> 完成上述正确配置，重启redis服务器，执行set k1 v1查看aof文件是否正常

![](./images/2023-03-30-16-26-20-image.png)

![](./images/2023-03-30-16-26-29-image.png)

> 查看三大配置文件

- 复习配置项

![](./images/2023-03-30-16-27-23-image.png)

- 本次操作

![](./images/2023-03-30-16-27-53-image.png)

> k1不停111111暴涨

![](./images/2023-03-30-16-28-36-image.png)

> 重写触发

![](./images/2023-03-30-16-29-00-image.png)

3. 手动触发案例02

> 客户端向服务器发送bgrewriteaof命令

![](./images/2023-03-30-16-30-01-image.png)

4. 结论

![](./images/2023-03-30-16-30-23-image.png)

##### 重写原理

1：在重写开始前，redis会创建一个“重写子进程”，这个子进程会读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。

2：与此同时，主进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。

3：当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中

4：当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中

5：重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似

#### AOF游湖配置项详解

> 配置文件APPEND ONLY MODE模块

![](./images/2023-03-30-16-31-51-image.png)

#### 小总结

![](./images/2023-03-30-16-32-11-image.png)

### RDB-AOF混合持久化

#### 官网建议

![](./images/2023-03-30-17-01-33-image.png)

#### rdb vs aof

1. 问题
- 可否共存？

- 共存听谁的？
2. 官方文档

![](./images/2023-03-30-17-02-58-image.png)

3. 数据恢复顺序和加载流程

![](./images/2023-03-30-17-03-25-image.png)

![](./images/2023-03-30-17-03-39-image.png)

#### 你怎么选？用哪个？

- RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储

- AOF持久化方式方式记录每次对服务器写的操作，当服务器重启的时候会优先载入AOF文件来恢复原始的数据，AOF命令以redis协议追加保存每次写的操作到文件末尾。

#### 同时开启两种持久化方式

- 在这种情况下，`当redis重启的时候会优先载入AOF文件来恢复原始的数据`，因为在通常情况下AOF文件保存数据集要比RDB 文件保存的数据集要完整。

- RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？`作者建议不要`，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），留着rdb作为一个万一的手段。

#### 推荐方式

> RBD+AOF混合模式

结合了RDB和AOF的优点，既能快速加载又能避免丢失过多的数据。

![](./images/2023-03-30-17-54-22-image.png)

1 开启混合方式设置

设置aof-use-rdb-preamble的值为 yes   yes表示开启，设置为no表示禁用

2 RDB+AOF的混合方式---------> 结论：RDB镜像做全量持久化，AOF做增量持久化

先使用RDB进行快照存储，然后使用AOF持久化记录所有的写操作，当重写策略满足或手动触发重写的时候，将最新的数据存储为新的RDB记录。这样的话，重启服务的时候会从RDB和AOF两部分恢复数据，既保证了数据完整性，又提高了恢复数据的性能。简单来说：混合持久化方式产生的文件一部分是RDB格式，一部分是AOF格式。**----》AOF包括了RDB头部+AOF混写**

![](./images/2023-03-30-17-54-38-image.png)

### 纯缓存模式

#### 同时关闭RDB+AOF

1. save ""
- 禁用rdb

- 禁用rdb持久化模式下，我们任然可以使用`save`、`bgsave`生成rdb文件
2. appendonly no
- 禁用aof

- 禁用aof持久化模式下，我们任然可以使用命令`bgrewriteaof`生成aof文件
